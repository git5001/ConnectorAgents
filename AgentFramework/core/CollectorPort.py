# AgentFramework/core/CollectorPort.py
# ────────────────────────────────────
"""
CollectorPort – an INPUT-side ToolPort that automatically re-assembles
a stream of list fragments (generated by ToolPort.send’s built-in
splitting logic) into a single `ListModel`.

The implementation re-uses *exactly* the algorithms that powered the
former ListCollectionAgent, so behaviour is byte-for-byte identical.
"""
import time
from typing import List, Tuple, Type, Dict, Any, Optional, Union, TypeVar, Generic, Callable

from pydantic import BaseModel, Field

from AgentFramework.core.ToolPort import ToolPort
from AgentFramework.core.listutil import (          # ← same helpers as before
    find_common_complete_uuids,
    compare_lists,
    find_last_non_one,
)

T = TypeVar("T", bound=BaseModel)

class ListModel(BaseModel, Generic[T]):
    """
    The resulting list data.
    """
    data: List[T] = Field(default_factory=list, description="Combined list result")

def transform_list_2_modellist(params: List[BaseModel]) -> ListModel:
    """Converts result of a list of models to a model list."""
    result: ListModel = ListModel(data=params)
    return result

def transform_modellist_2_list(params: ListModel) -> List[BaseModel]:
    """Converts result of a list of models to a model list."""
    return params.data


class CollectorPort(ToolPort):
    """
    Works exactly like a normal *INPUT* ToolPort **except** that it
    buffers list fragments until ALL siblings of a split message
    (same root-UUID) have arrived, then emits a single `ListModel`
    containing the original messages *in order*.

    It replaces the now-obsolete `ListCollectionAgent`.
    """

    # ------------------------------------------------------------------ #
    # construction                                                       #
    # ------------------------------------------------------------------ #
    def __init__(self,
                 direction: ToolPort.Direction,
                 model: Type[BaseModel],
                 uuid: str) -> None:
        if direction is not ToolPort.Direction.INPUT:
            raise ValueError("CollectorPort may only be used as an INPUT port")

        super().__init__(direction, model, uuid)

        # internal buffer – identical payload structure as the old agent
        # List of tuples: (params, cleaned_list, parents)
        self._collector_data: List[Tuple[BaseModel, List[str], List[str], int, str|None]] = []

    # ------------------------------------------------------------------ #
    # helpers copied verbatim from ListCollectionAgent                   #
    # ------------------------------------------------------------------ #
    def _replace_if_needed(self, parents: List[str], n: int) -> None:
        if n >= len(parents) or n < 0:
            raise IndexError(
                f"Index {n} is out of range for 'parents' list of length {len(parents)}"
            )

        value = parents[n]
        parts = value.rsplit(":", 2)

        if len(parts) != 3:
            raise ValueError(
                f"Invalid format for parent entry: '{value}'. "
                "Expected format 'something:a:b'"
            )

        prefix, a_str, b_str = parts
        a, b = int(a_str), int(b_str)

        if a == 0 and b == 1:
            raise ValueError(
                f"Invalid value '{value}': ends with ':0:1', "
                "which is not allowed for list collections"
            )

        parents[n] = f"{prefix}:0:1"



    # ------------------------------------------------------------------ #
    # receive – the heart                                                #
    # ------------------------------------------------------------------ #
    def receive(self, message: BaseModel,
                parents: List[str],
                unique_id: str = None,
                post_transformer: Optional[Callable[[BaseModel], Union[BaseModel, List[BaseModel]]]] = None) -> None:
        """
        Forwards
        a   ListModel(data=[…])   straight into the queue           OR
        waits until all fragments are present and then forwards the
        aggregated `ListModel`.
        """
        if self.direction != ToolPort.Direction.INPUT:
            raise ValueError("OUTPUT ports cannot receive messages.")

        # ---- fast path: single, already-complete message --------------
        cleaned_list = [item.split(":")[0] if ":" in item else item for item in parents]
        all_valid = all(item == "" or item.endswith(":0:1") for item in parents)

        if all_valid:
            # Wrap the single element exactly like ListCollectionAgent did
            wrapped = ListModel(data=[message])
            self.queue.append((parents, int(time.time() * 1000), unique_id, wrapped))
            return

        # ---- slow path: part of a split list --------------------------
        # Store until we have every sibling of this root-UUID
        self._collector_data.append((message, cleaned_list, parents, int(time.time() * 1000), unique_id))

        list_length = find_last_non_one(parents)
        if len(self._collector_data) < list_length:
            return  # still waiting for more items

        parents_list = [item[2] for item in self._collector_data]
        cleaned_common_sublists = find_common_complete_uuids(parents_list)
        if not cleaned_common_sublists:
            return  # fragments belong to different root-lists

        cleaned_sublist = cleaned_common_sublists[:1]
        new_data: List[Tuple[BaseModel, List[str], List[str], int, str]] = []
        output_payloads: List[BaseModel] = []
        output_ids: List[str] = []

        for data_params, data_cleaned_list, data_parents, data_time, data_id in self._collector_data:
            if not compare_lists(data_cleaned_list, cleaned_sublist):
                new_data.append((data_params, data_cleaned_list, data_parents, data_time, data_id ))
            else:
                output_payloads.append(data_params)          # agent.run was identity
                output_ids.append(data_id)

        self._collector_data = new_data

        # ----- build the synthetic parent path -------------------------
        # “last element” := fragment descriptor we are replacing
        agg_parents = parents.copy()
        self._replace_if_needed(agg_parents, len(cleaned_common_sublists) - 1)

        # ----- final aggregated message (ListModel) --------------------
        aggregated = transform_list_2_modellist(output_payloads)
        transformed_message = post_transformer(aggregated) if post_transformer else aggregated
        # unique_id = ":".join(output_ids)
        unique_id = ":".join(dict.fromkeys(output_ids))
        self.queue.append((agg_parents, int(time.time() * 1000), unique_id, transformed_message))

    # ------------------------------------------------------------------ #
    #  (optional) serialisation helpers so checkpoints survive           #
    # ------------------------------------------------------------------ #
    def _serialise_collector_state(self) -> Dict[str, Any]:
        """
        Represent _collector_data with encode_payload so
        ConnectedAgent._dump_port can embed it.
        """
        from util.SerializeHelper import encode_payload
        serialised: List[Tuple[Any, List[str], List[str], int, str]] = []
        for params, clist, parents, timestamp, unique_id in self._collector_data:
            serialised.append((encode_payload(params), clist, parents, timestamp, unique_id))
        return {"collector_data": serialised}

    def _load_collector_state(self, blob: Dict[str, Any]) -> None:
        from util.SerializeHelper import decode_payload
        serialised = blob.get("collector_data", [])
        self._collector_data.clear()
        for payload, clist, parents, timestamp, unique_id in serialised:
            self._collector_data.append((decode_payload(payload), clist, parents, timestamp, unique_id))
